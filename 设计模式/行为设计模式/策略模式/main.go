package main

import "fmt"

/**
策略模式介绍：
策略模式 --- 行为设计模式
思想：允许在运行时选择算法的行为。策略模式将不同的算法封装成独立的策略类，使得它们可以相互替换，而不影响客户端代码。
这样，客户端可以根据需要选择不同的策略来解决特定的问题

适用场景：
1. 需要根据不同的条件或情况选择不同算法或行为的情况。例如，根据不同的支付方式（策略）来计算订单的支付金额
2. 需要在运行时动态地切换算法或行为的情况。例如，根据系统负载情况选择不同的数据缓存策略
3. 需要将方法的实现细节与使用者隔离，使得使用者不依赖于具体的算法实现。这样可以降低耦合性并提高代码的可维护性
4. 需要时常扩展系统以支持新的算法或行为。通过添加新的策略类，可以方便地扩展系统功能而不影响现有代码

具体应用场景：
1. 排序算法：不同的排序算法可以作为策略类，根据需要选择不同的排序算法，例如冒泡排序、插入排序、快速排序等 (同样适用于搜索精排、重排的排序算法)
2. 文件压缩：不同的压缩算法可以作为策略类，根据文件类型或需求选择不同的压缩算法，例如ZIP压缩、RAR压缩、GZIP压缩等。
3. 日志记录：不同的日志记录策略可以根据日志级别选择不同的记录方式，例如将日志记录到文件、数据库或发送到远程服务器等。
4. 支付方式：不同的支付方式可以作为策略类，根据用户选择或订单金额选择不同的支付方式，例如信用卡支付、支付宝支付、微信支付等。

策略模式的优缺点
优点：
-- 提供了更好的代码组织结构：策略模式将不同的算法封装成独立的策略类，使得每个策略类都专注于解决特定的问题。这样可以提高代码的可读性和可维护性，并且使得代码结构更加清晰，符合单一职责原则
-- 提供了更好的可扩展性：通过添加新的策略类，可以方便地扩展系统的功能，而无需修改已有的代码，使系统更加灵活和可扩展，符合开闭原则
-- 提供了更好的灵活性：策略模式依赖于抽象的策略接口，而不依赖于具体的策略实现，使用者只需要调用统一接口即可，这种松耦合有助于减少对象之间的依赖关系，提高代码的可维护性和扩展性，符合迪米特法则
-- 同时客户端依赖于抽象的策略接口，而不依赖于具体的策略类。这种依赖倒置的设计使得客户端与具体的策略类解耦，也符合依赖倒置原则
-- 允许在运行时动态地切换和选择算法，使得系统能够根据不同的需求选择合适的策略。这种灵活性可以根据实际情况进行动态调整，提高系统的适应性和可变性，
-- 算法的具体实现被封装在各个策略类中，使用者只需要关注选择合适的策略即可，不需要了解具体的算法实现细节，这种解耦可以降低代码的依赖性，提高代码的可维护性
缺点：
-- 如果你的算法极少发生改变，无需引入新的类和接口，使用该策略只会使得程序复杂化
-- 增加了类的数量：使用策略模式会引入多个策略类，如果策略较多，可能会导致类的数量增加，使得代码变得复杂。因此，在使用策略模式时需要权衡类的数量和代码的可读性
-- 客户端需要了解不同的策略：客户端需要了解不同的策略类和它们之间的区别，以便选择合适的策略。这可能会增加客户端的复杂性，特别是当策略较多时
-- 策略切换的开销：由于策略模式允许在运行时动态切换策略，可能会带来一定的开销。在某些性能敏感的场景下，这种开销可能需要考虑

和命令模式的区别：
策略模式强调将算法或策略封装成对象，并使其可互换。它通过上下文对象和具体策略类之间的关系来实现这一点
命令模式强调将请求（命令）封装成对象，以及命令的执行者和发送者的解耦。它通过命令对象和命令调用者之间的关系来实现这一点
**/

// 例子：构建内存缓存的情形。 由于处在内存中， 故其大小会存在限制。 在达到其上限后， 一些条目就必须被移除以留出空间。 此类操作可通过多种算法进行实现。
// 一些流行的内存淘汰算法：
// 最少最近使用 （LRU）： 移除最近使用最少的一条条目。
// 先进先出 （FIFO）： 移除最早创建的条目。
// 最少使用 （LFU）： 移除使用频率最低一条条目。
// 使用策略模式解耦缓存类和这些算法，以便于运行时更改算法，并且在新增算法时无需改变缓存类

// 1. 策略接口以及具体策略实现，传入参数为缓存类，函数则由具体实现类实现
type EvictionAlgo interface {
	evict(c *Cache)
}

// FIFO 算法实现
type FIFOAl struct{}

func (fa *FIFOAl) evict(c *Cache) {
	fmt.Println("FIFO 算法淘汰缓存")
}

// LRUAl 算法实现
type LRUAl struct{}

func (la *LRUAl) evict(c *Cache) {
	fmt.Println("LRUAl 算法淘汰缓存")
}

// 2. 缓存类实现
type Cache struct {
	Storage      map[string]string
	EvictionAlgo EvictionAlgo
	capacity     int
	maxCapacity  int
}

func initCache(e EvictionAlgo) *Cache {
	return &Cache{
		Storage:      make(map[string]string),
		EvictionAlgo: e,
		capacity:     0,
		maxCapacity:  2,
	}
}

func (c *Cache) SetEvictionAlgo(e EvictionAlgo) {
	c.EvictionAlgo = e
}

func (c *Cache) add(key, value string) {
	if c.capacity == c.maxCapacity {
		c.evict()
	}
	c.capacity++
	c.Storage[key] = value
}

func (c *Cache) del(key string) {
	delete(c.Storage, key)
}

func (c *Cache) evict() {
	c.EvictionAlgo.evict(c)
	c.capacity--
}

// 3. 测试
func main() {
	cache := initCache(&LRUAl{})
	cache.add("a", "1")
	cache.add("b", "2")
	cache.add("c", "3")
	cache.SetEvictionAlgo(&FIFOAl{})
	cache.add("d", "4")
	cache.add("e", "5")
}
