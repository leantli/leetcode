package main

// https://leetcode.cn/problems/find-the-duplicate-number/
// 287. 寻找重复数

// 还能用什么方法呢？看起来也不能用 摩尔投票，因为出现的次数不一定超过数组长度一半
// 看了一下题解，发现可以用 二分？！
// 我是没想到的。。。
// 整个思路时类似 根据大小判断猜数字
// l 为 1， r 为 n，因为数字可能出现的范围就是 [1,n]
// 因此确定上下边界开始二分猜数字
// 那么如何确定下一次猜数字是往上区间还是下区间呢？
// 根据本数组中，小于当前数字的数的出现次数
// 显然，每个数只出现 1 次，则小于当前数的所有数出现的次数相加，也必定小于当前数
// 比如 3，小于等于 3 的数只有 1、2、3，出现次数为 3，必定是小于等于 3 的
// 确保下次猜数字往上区间去猜(即往有异常的方向去猜)
func findDuplicate(nums []int) int {
	l, r := 1, len(nums)-1
	// l < r 保证退出循环时，l 和 r 重合
	for l < r {
		mid := l + (r-l)/2
		cnt := 0
		for _, num := range nums {
			if num <= mid {
				cnt++
			}
		}
		// 当 cnt 大于 mid 时异常，则左侧区间有重复的，不正常
		// 下一次要猜的数字，一定在 [l, mid] 区间中
		if cnt > mid {
			r = mid
		} else {
			l = mid + 1
		}
	}
	return l
}

// // 这里首先是 [1,n] 中只存在一个 重复的 数，并且该数不确定出现几次，可能 2+ 次
// // 因此我们无法对该数直接进行位运算，因为我们连其出现的次数都无法确定
// // 这里我们可以关注到，数组为 n+1, 并且每个数都是在 [1,n] 的，因此我们可以原地操作
// // 遇到一个数，就将该数作为下标，将对应下标的数 +n, 当我们遇到某个数第二次时，发现该下标对应的数已经大于 n 了，因此可以直接返回该重复的数
// // emmm, 做完后发现题目要求不对 num 进行操作，因此该方法不行
// func findDuplicate(nums []int) int {
// 	n := len(nums)
// 	for _, num := range nums {
// 		// 将 num 对应的下标 进行判断操作
// 		index := num % n
// 		if nums[index] <= n {
// 			nums[index] += n
// 		} else {
// 			return num
// 		}
// 	}
// 	return -1
// }
