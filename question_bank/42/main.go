package main

// https://leetcode.cn/problems/trapping-rain-water/
// 42. 接雨水

// 正常情况下要计算两个水坑之间的容积
// 我们得先找到水坑的两个高，保证这两个高中间的水不会流走
// 但是这并不方便，比如 [6,0,3,0,6]，此时我们会先找到 6 和 3
// 接着就直接计算了二者之间的容器，但实际上，6 可以和后面的 6 构成更大的容器
// 所以，我们必须同时找到两边的最高值, 那么如何找到两边的最高值呢？
// 每到一列，我们就向左向右去找比它高的，如果都找到了，那么就用较矮的高减去其本身的高度即可
// 但是这样的话，每一列都要找一遍，相当于 n*n 的时间复杂度
// 这里有个小技巧思路：
// 我们可以用两个指针分别指向首尾
// 共同维护两边的最高值，哪边的最高值较低，那么这一边的指针就向中间步进
// 并判断是否是更高的高度，更高则更新这边的最高值，更低则计算此处能装多少水
// 因为我们是移动最高值较低的一边，因此另一边的高度是足够支持此处容纳水的
// 并且如果是同一边有更高的值，也不会影响计算，每一边的高度都只会越来越高
// 因此遇到低的，就一定能直接计算这一步的容水情况
func trap(height []int) int {
	l, r := 0, len(height)-1
	lh, rh := height[l], height[r]
	var cap int
	for l < r {
		if lh < rh {
			l++
			if lh > height[l] {
				cap += lh - height[l]
			} else {
				lh = height[l]
			}
		} else {
			r--
			if rh > height[r] {
				cap += rh - height[r]
			} else {
				rh = height[r]
			}
		}
	}
	return cap
}
