package main

import "fmt"

/**
题目描述:
A、B两个人把苹果分为两堆，A希望按照他的计算规则等分苹果，他的计算规则是按照二进制加法计算，并且不计算进位 12+5=9(1100 + 0101=9)，B的计算规则是十进制加法，包括正常进位，B希望在满足A的情况下获取苹果重量最多。输入苹果的数量和每个苹果重量，输出满足A的情况下B获取的苹果总重量。如果无法满足A的要求，输出-1。
数据范围
1<= 总苹果数量 <= 20000
1 <= 每个苹果重量 <= 10000
输入描述:
输入第一行是苹果数量: 3输入第二行是每个苹果重量: 3 5 6
输出描述:
输出第一行是B获取的苹果总重量: 11
补充说明:
按照A的计算方法 5+6=3 (101+110不算进位的话值为3)
**/

// 根据 A 的计算方式：二进制加法但不进位---此时两个数相加，单纯就是取异或
// A 的条件：基于异或，将苹果等分，那我们知道，等分后，两堆苹果二进制相等，取异或必定为 0
// 因此我们可以判断，全部的苹果取异或，如果能等分，则全部异或结果为 0，不为 0 则不能等分，直接返回 -1
// 如果可以得到异或结果为 0，此时其中任意一个苹果和其他苹果的总二进制加法结果，异或后为 0
// 因此对于 B 的条件，我们只需要将 最小的苹果给 A，其他的都给 B 即可

func main() {
	var n int
	fmt.Scan(&n)
	apples := make([]int, n)
	for i := range apples {
		fmt.Scan(&apples[i])
	}
	var xor, total int
	for _, apple := range apples {
		xor ^= apple
		total += apple
	}
	if xor != 0 {
		fmt.Println(-1)
	}
	min := apples[0]
	for _, apapple := range apples {
		if apapple < min {
			min = apapple
		}
	}
	fmt.Println(total - min)
}
