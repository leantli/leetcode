package main

// https://leetcode.cn/problems/container-with-most-water/
// 11. 盛最多水的容器

// 容器能容纳的容积为 底边长*两高中较短的高
// 这样的话，我们不能仅仅找最长的两个高，还得考虑两高的距离
// 我们能否排除两高或者底边长两个因素中的一个？
// 高应该是不能排除的，我们很难说确定某个特别的高度，其不具备单调的性质
// 而高之间底边长短的影响还是很大的，因此无法排除高的因素
// 那么能否排除底边的影响？比如说，某个长度的底边，其容器最大可能是多少？
// 此时就比较简单了，固定某个高度，寻找其容器最大的底边与另一个高度
// 这里可以分两种考虑：
// 1. 固定某个高度，找另一个边，每次找到的另一个边，其高度一定比之前找的边高度要高或者大于等于当前边
// 这在一定程度上有剪枝，但再想其实不行，比如[5,4,3,3,3]，这里后面的3就不会被考虑了，但是加上底边的情况
// 其实容器比[5,4]更大，难道只能暴力？
// 2. 固定某个底边，此时只需考虑这个底边长度的两个高，哪个低就按其高度计算容器
// 我们假设底边初始为最长，按底边低的去计算容器，并且缩减低的这边的底边长度
// 因为这个低的已经不可能得到更大的容器了，此时其底边长是最长的，其对应的另一个高也比其高
// 以这个低的为高，最大的容器已经算出来了，所以此时直接缩减它所在这边的底长，变换这边的高度
// 由此可以计算出每个边的最大容器，不会导致面积最大值丢失
func maxArea(height []int) int {
	n := len(height)
	l, r, res := 0, n-1, 0
	width := r
	for l < r {
		var lower int
		if height[l] < height[r] {
			lower = height[l]
			l++
		} else {
			lower = height[r]
			r--
		}
		curCap := lower * width
		width--
		if res < curCap {
			res = curCap
		}
	}
	return res
}
