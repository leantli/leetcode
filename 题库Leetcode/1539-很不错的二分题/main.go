package main

// https://leetcode.cn/problems/kth-missing-positive-number/?envType=study-plan&id=binary-search-beginner&plan=binary-search&plan_progress=cnhyx51
// 1539. 第 k 个缺失的正整数

// 注意，严格升序排列，时间复杂度还要小于 O(n)，这不明显是要二分？！
// 如果没有这个进阶要求，只需遍历即可，遇到缺失的数则 k--，当 k == 0 时即为缺失的数
// 假设一下，l = 0, r = 6, mid = 3, 此时其前面应该有 1,2,3, arr[mid] 应该为 4，若arr[mid] 不为 4，而是 6
// 则前面必定存在缺失的正整数，缺失的正整数数量为 arr[mid] - (mid+1)，比如此时缺失的数量为 2，缺失了 4、5
// 当 mid = 2 时，我们找到 arr[mid] = 3，并没有缺失的数，假设 此时 k=2
// 我们要找到的分界点，就是 缺失的数 < k 的最大数，其下一个数就会导致缺失的数大于等于 k
// 此时缺失的数 = (k - 当前数 导致缺失的数量) + 当前数
// 但是这个感觉遇到缺失的数超过数组长度时不好处理？

// // 没想到二分咋搞....还是先按简单题模拟一下
// func findKthPositive(arr []int, k int) int {
// 	cur := 1
// 	for _, num := range arr {
// 		for cur != num {
// 			k--
// 			if k == 0 {
// 				return cur
// 			}
// 			cur++
// 		}
// 		cur++
// 	}
// 	return arr[len(arr)-1] + k
// }

// 注意，严格升序排列，时间复杂度还要小于 O(n)，这不明显是要二分？！
// 如果没有这个进阶要求，只需遍历即可，遇到缺失的数则 k--，当 k == 0 时即为缺失的数
// 假设一下，l = 0, r = 6, mid = 3, 此时其前面应该有 1,2,3, arr[mid] 应该为 4，若arr[mid] 不为 4，而是 6
// 则前面必定存在缺失的正整数，缺失的正整数数量为 arr[mid] - (mid+1)，比如此时缺失的数量为 2，缺失了 4、5
// 当 mid = 2 时，我们找到 arr[mid] = 3，并没有缺失的数，假设 此时 k=2
// 我们要找到的分界点，就是 缺失的数 < k 的最大数，其下一个数就会导致缺失的数大于等于 k
// 此时缺失的数 = (k - 当前数 导致缺失的数量) + 当前数
// 但是这个感觉遇到缺失的数超过数组长度时不好处理？(X) 其实也没啥不行，就像万金油模板时，r 初始在 范围之外
// 这里主要需要特殊处理的，反而是初始位置，因为我们需要注意到，缺失的数其实需要依赖 当前数(二分找到的值)
// 而初始位置是根本没有该值的
func findKthPositive(arr []int, k int) int {
	// 特殊处理，当第一个数大于 k 是，缺失的第 k 个正整数就是 k
	// 这里必须要特殊处理，因为二分完毕后的后处理，需要依赖上一个未超过 k 缺失数量的数，而如果缺失的数在第一个数之前，就无法处理
	if arr[0] > k {
		return k
	}
	// 注意，l 和 r 都在 正常取值范围(缺失的正整数) 之外
	l, r := 0, len(arr)
	for l+1 != r {
		mid := l + (r-l)/2
		lose := arr[mid] - (mid + 1)
		// 最终 l 会落在 缺失数量小于 k 的位置， r 会落在第一个缺失数量大于等于 缺失的数 的位置
		if lose < k {
			l = mid
		} else {
			r = mid
		}
	}
	return (k - (arr[l] - (l + 1))) + arr[l]
}
